# Javscipt 进阶

## 作用域

> 作用域规定了变量能够被访问的范围，离开这个范围变量就不能被访问

**作用域分为：**

 ### 局部作用域

局部作用域分为函数作用域和块作用域。

**函数作用域：**

> 在函数内部声明的变量只能在函数内部被访问，外部无法访问

总结：

1. 函数内部声明的变量，在函数外部无法被访问
2. 函数的参数也是函数内部的局部的变量
3. 不同函数内部声明的变量无法相互访问
4. 函数执行完毕后，函数的变量实际被清空了

**块作用域：**

> 在JavaScript中使用 `{}` 包裹的代码块内部声明的变量外部将有可能无法被访问

```javascript
for(let i=0;i<10;i++){
    // i 只能的该代码块中被访问
    console.log(i)
}
// 超出了t的作用域 ，报错
  console.log(i)
```

**总结：**

1. `let` 声明的变量，`const` 声明的常量，都会产生块级作用域
2. `var` 声明的变量不会产生块级作用域
3. 不同代码块之间的变量无法相互访问
4. 推荐使用 `let` 和  `const`

 ### 全局作用域

> 在 `<script>` 标签 和 `.js` 文件的**最外层**就是全局作用域，在此声明的变量在函数内部也可以访问，全局作用域下声明的变量，任何其他作用域都可以被访问

```javascript
//全局作用域，下声明变量num
const num=10
function fn(){
    //函数内部可以使用
    console.log(num)
}
```

**注意：**

1. 为 window 对象动态添加的属性默认也是全局的，不推荐
2. 函数未使用任何关键字声明的变量为全局变量，不推荐
3.  尽可能少的声明全局变量，防止全局变量被污染

### 作用域链

> 作用域链本质是底层的变量查找机制

- 函数在被执行时，会优先找当前函数作用域中查找变量
- 如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域

```javascript
//全局作用域
let a = 1
let b = 2
//局部作用域
function f() {
    let a = 1
    function g() {
        a = 2
        console.log(a)  // 2
    }
    g()
}
f()
```

**总结：**

1. 嵌套更新的作用域串联起来形成了作用域链
2. 相同作用域链中按着从小到大的规则查找变量
3. 子作用域能够访问父级作用域，父级作用域无法访问子级作用域

### JS 的垃圾回收机制

>垃圾回收机制 (Garbage Collection) 简称 GC
>
>JS 中的内存的分配和回收都是自动完成的，，内存在不使用的时候会被垃圾回收器自动回收。
>
>但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况
>
>不再用到的内存，没有及时释放，就叫做内存泄漏

**内存的生命周期 ：**

1. 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存
2. 内存使用：即读写内存，也就是使用变量、函数等
3. 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存
4. - 全局变量一般不会回收(关闭页面回收)；
   - 一般情况下局部变量的值, 不用了, 会被自动回收掉



**垃圾回收算法说明**

>所谓垃圾回收, 核心思想就是如何判断内存是否已经不再会被使用了, 如果是, 就视为垃圾, 释放掉
>下面介绍两种常见的浏览器垃圾回收算法: 引用计数法 和 标记清除法

引用计数
IE采用的引用计数算法, 定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。
算法：

1. 跟踪记录每个值被引用的次数。
2. 如果这个值的被引用了一次，那么就记录次数1
3. 多次引用会累加。
4. 如果减少一个引用就减1。
5. 如果引用次数是0 ，则释放内存。

引用计数算法是个简单有效的算法。
但它却存在一个致命的问题：嵌套引用。
如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。

标记清除法
现代的浏览器已经不再使用引用计数算法了。
现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。
核心：

1. 标记清除算法将“不再使用的对象”定义为“无法达到的对象”。
2. 就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。
3. 那些无法由根部出发触及到的对象被标记为不再使用，稍后进 行回收。

![image-20220720101238312](https://picgo-fantasy06.oss-cn-guangzhou.aliyuncs.com/img/image-20220720101238312.png)



### 闭包

>概念：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域
>简单理解：闭包 = 内层函数 + 外层函数的变量

```javascript
function outer() {
    const a = 1
    function f(){
        console.log(a)
    }
    f()
}
outer
//	内层函数调用外层函数的变量，就是闭包
```

作用： 封闭数据，提供操作，外部也可以访问函数内部的变量

基本格式：

![image-20220720102143313](https://picgo-fantasy06.oss-cn-guangzhou.aliyuncs.com/img/image-20220720102143313.png)

闭包应用：实现数据的私有
比如，我们要做个统计函数调用次数，函数调用一次，就++

普通写法

```javascript
let count = 1
function fn() {
    count++
     console.log(count)
}
fn() //2
fn() //3
```

这个count 是个全局变量，很容易被修改 

闭包写法：

```javascript
function fn() {
    let count = 1
  return function fun() {
        count++
       console.log(count)
    }
}
const result =fn()
result() //2
result() //3
```

实现了数据私有，无法直接修改count

 闭包可能引起的问题：内存泄漏



### 变量提升

>变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问（仅存在于var声明变量）

```javascript
console.log(str) //不报错 控制台显示undefined
var str = 'hello'
```

注意：
1. 变量在未声明即被访问时会报语法错误
2. 变量在var声明之前即被访问，变量的值为 undefined
3. let / const  声明的变量不存在变量提升
4. 变量提升出现在相同作用域当中
5. 实际开发中推荐先声明再访问变量



## 函数进阶

### 函数提升

函数提升与变量提升比较类似，是指函数在声明之前即可被调用。

### 函数参数

- 动态参数

  arguments 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参

  ```javascript
  //求和函数 不管用户传入几个实参，都要把和求出来
  function sum() {
      let s = 0
      for(let i = 0;i < arguments.length;i++){
          s += arguments[i]
      }
      return s
  }
  sum(5,10) //15
  sum(1,2,3) //6
  ```

- 剩余参数

  剩余参数允许我们将一个不定数量的参数表示为一个数组

  1. `...` 是语法符号，置于最末函数形参之前，用于获取多余的实参
  2. 借助 `...` 获取的剩余实参，是个真数组

  ```javascript
  function sum(...other) {
      let s = 0
      for(let i = 0;i < other.length;i++){
          s += other[i]
      }
      return s
  }
  sum(5,10) //15
  sum(1,2,3) //6
  ```

  区别：

  1. ... 是语法符号，置于最末函数形参之前，用于获取多余的实参
  2. 借助 ... 获取的剩余实参，是个真数组

---

展开运算符：`...`

> 展开运算符 (…)， 将一个数组进行展开，不会修改原数组

```javascript
const arr=[1,2,3,4,5]
console.log(...arr) //1 2 3 4 5
```

典型运用场景： 求数组最大值(最小值)、合并数组等

```javascript
const arr=[1,2,3,6,4,5]
const arr2=[7,8,9]
//最大值
const max=Math.max(...arr)
//合拼
const arr3=[...arr,...arr2]
```

展开运算符 or 剩余参数
剩余参数：函数参数使用，得到真数组
展开运算符：数组中使用，数组展开

### 箭头函数

**语法：**

```javascript
//普通函数
const fn = function (){
    ...
}
fn()
//1.箭头 无参数
const fn = () =>{
    ...
}
//2.只有一个参数
const fn = x=> {
    return x
}
//3.函数体只有一行代码，可以写一行上，无需写 return 直接返回值
const fn = (x,y) => x + y  //返回 x + y 的值
//加括号的函数体返回对象字面量表达式
const fn1 = uname =>({uname : uname}) 
console.log(fn1('叶湘伦')) //控制台：{uname:"叶湘伦"}
```

1. 箭头函数属于表达式函数，因此不存在函数提升
2. 箭头函数只有一个参数时可以省略圆括号 ()
3. 箭头函数函数体只有一行代码时可以省略花括号 {}，并自动做为返回值被
返回
4. 加括号的函数体返回对象字面量表达式

 **箭头函数参数：**

1. 普通函数有 `arguments` 动态参数
2. 箭头函数没有 `arguments `动态参数，但是有 剩余参数 `..args`

 **箭头函数 this：**
在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的 this 值
箭头函数不会创建自己的 this ,它只会从自己的作用域链的上一层沿用 this 。

![image-20220720110228858](https://picgo-fantasy06.oss-cn-guangzhou.aliyuncs.com/img/image-20220720110228858.png)

![image-20220720110259612](https://picgo-fantasy06.oss-cn-guangzhou.aliyuncs.com/img/image-20220720110259612.png)

在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window，因此，DOM事件回调函数为了简便，还是不太推荐使用箭头函数



## 数组解构

> 数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法。

```javascript
// 普通的数组
  let arr = [1, 2, 3];
  // 批量声明变量 a b c 
  // 同时将数组单元值 1 2 3 依次赋值给变量 a b c
  let [a, b, c] = arr;
  console.log(a); // 1
  console.log(b); // 2
  console.log(c); // 3
```

基本语法：

1. 赋值运算符 `=` 左侧的 `[]` 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量
2. 变量的顺序对应数组单元值的位置依次进行赋值操作
3. 变量的数量大于单元值数量时，多余的变量将被赋值为  `undefined`
4. 变量的数量小于单元值数量时，可以通过 `...` 获取剩余单元值，但只能置于最末位
5. 允许初始化变量的默认值，且只有单元值为 `undefined` 时默认值才会生效

**对象解构**

```javascript
 // 普通对象
  const user = {
    name: '小明',
    age: 18
  };
  // 批量声明变量 name age
  // 同时将数组单元值 小明  18 依次赋值给变量 name  age
  const {name, age} = user

  console.log(name) // 小明
  console.log(age) // 18
```

总结：

1. 赋值运算符 `=` 左侧的 `{}` 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量
2. 对象属性的值将被赋值给与属性名相同的变量
3. 对象中找不到与变量名一致的属性时变量值为 `undefined`
4. 允许初始化变量的默认值，属性不存在或单元值为 `undefined` 时默认值才会生效

## 遍历数组 forEach 方法

>forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数

```javascript
遍历数组.forEach(function (当前数组元素,索引号){
    //函数体
}) 
```

注意：
1. forEach 主要是遍历数组
2. 参数当前数组元素是必须要写的， 索引号可选。

## 筛选数组 filter 方法

<img src="https://picgo-fantasy06.oss-cn-guangzhou.aliyuncs.com/img/image-20220720111855654.png" alt="image-20220720111855654" style="zoom: 200%;" />

>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素

主要使用场景： 筛选数组符合条件的元素，并返回筛选之后元素的新数组

```javascript
遍历数组.filter(function (当前数组元素,索引号){
    return 筛选条件
}) 
//筛选数组大于30的元素
const arr=[10,26,62,61,56,12,36]
const re = arr.filter(function(item){
    return item > 30
})
console.log(re) //[62,61,56,36]
```

返回值：返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组
参数：currentValue 必须写， index 可选
因为返回新数组，所以不会影响原数组

